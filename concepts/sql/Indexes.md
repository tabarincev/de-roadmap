## Indexes
## Плюсы
#### `Ускорение запросов`
Индексы значительно ускоряют выполнение запросов, особенно для операций равенства, сравнений и сортировки данных.

```sql
SELECT *
FROM employees
WHERE department = 'HR';
```
Индекс на столбце department ускорит выполнение этого запроса.

#### `Покрытие запросов`
В некоторых случаях индексы могут содержать все данные, необходимые для выполнения запроса, что позволяет избежать чтения самих строк таблицы (так называемый `Покрывающий индекс`).

```sql
SELECT
  name,
  age
FROM
  employees
WHERE department = 'IT';
```
Если индекс покрывает столбцы name, age и department, то чтение строк таблицы не потребуется.

#### `Поддержка ограничений`
Индексы могут использоваться для реализации ограничений на уникальность данных (UNIQUE), а также для обеспечения ссылочной целостности (FOREIGN KEY)

## Минусы
  - Допольнительная память на хранение индекса
  - Большое количество индексов замедляет `INSERT`, `UPDATE`, `DELETE` (индекс обновляется)
  - В небольших таблицах (< 10_000 строк) не имеет смысла
  - Столбцы с `NULL`
  - В OLAP системах фильтрация по диапозону (партиции), а не по конкретным записям
    
- #### Тип индекса:
    - Cluster
    - Non-Cluster
    - Unique
    - Composite
    - Covering

- #### Реализации индексов:
  - B-Tree
  - Hash
  - GIN
  - GiST (generalized search tree)
  - SP-GiST
  - BRIN


## Тип индекса
## Cluster
- Сортирует и физически хранит таблицу в определенном порядке
- Только 1 кластерный индекс
- Эффективен для поиска по диапозону

## Non-Cluster
- Хранится отдельно от данных таблицы
- Таблица может иметь несколько индексов
- Эффективен для поиска по конкретным значениям

## Unique
- Гарантирует уникальность значений

```sql
CREATE UNIQUE INDEX idx_user ON test.user USING BTREE (id);
```

## Composite
- Состоит из нескольких столбцов
- Эффективен для поиска по нескольким столбцам

## Covering
- Копирует используемые в запросе неключевые значения в сам индекс

```sql
CREATE INDEX idx_example ON table_name (column1) INCLUDE (column2);
```

#### Преимущества:
  - Значительное улучшение производительности запросов, так как нет необходимости обращаться к основной таблице
  - Уменьшение числа обращений к диску, особенно для часто используемых запросов с выборкой нескольких колонок
#### Недостатки:
  - Покрывающие индексы могут занимать больше места в памяти, особенно если в них включены несколько дополнительных колонок.
  - Увеличение времени на операции вставки, обновления и удаления, так как индекс требует обновления при изменениях данных.

#### Покрывающие индексы стоит использовать в следующих случаях:
- Для оптимизации часто выполняемых SELECT-запросов, которые выбирают несколько колонок.
- Когда необходимо минимизировать количество обращений к диску, чтобы ускорить выполнение запросов.
- Для OLAP, где важно быстрое чтение данных без необходимости частых обновлений.

## Реализации индекса
## B-Tree
- Основан на работе ```B-Tree``` дерева.
- Подходит для операций сравнения (`<`, `>`, `BETWEEN`), равенства (`=`) и сортировки.
- Хорошо оптимизирован для большинства операций чтения и поиска.
- Покрывает до 90% задач по индексации в типичных приложениях.
- Не рекомендуется для данных с высокой степенью повторения, так как эффективность индекса в таких случаях может снижаться
  
Создание простого B-Tree индекса
```sql
CREATE INDEX idx_user ON test.user (id);
```

## Hash

## GIN

## GiST

## SP-GiST

## BRIN
